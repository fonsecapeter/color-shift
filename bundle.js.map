{"version":3,"sources":["webpack:///webpack/bootstrap ff90ac648b16fa2075cc","webpack:///./lib/color_shift.js","webpack:///./lib/game_view.js","webpack:///./lib/game.js","webpack:///./lib/player.js","webpack:///./lib/moving_shape.js","webpack:///./lib/util.js","webpack:///./lib/constants.js","webpack:///./lib/shape.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;AClCD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAkB,qBAAqB,EAAE,EAAE;AAC3C,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC,UAAU;AAC1C;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,8CAA6C,UAAU;AACvD;AACA;AACA;AACA;;AAEA;;;;;;;AC5EA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;;;;;;;AC3IA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C;;AAE3C;AACA;;;AAGA;AACA,4BAA2B;AAC3B,kCAAiC,oCAAoC;AACrE,kEAAiE,gBAAgB;AACjF,MAAK,OAAO;AACZ,kCAAiC,oCAAoC;AACrE,iEAAgE,iBAAiB;AACjF;AACA,IAAG;AACH,4BAA2B;AAC3B,kCAAiC,oCAAoC;AACrE,kEAAiE,gBAAgB;AACjF,MAAK,OAAO;AACZ,kCAAiC,oCAAoC;AACrE,iEAAgE,iBAAiB;AACjF;AACA;AACA,qDAAoD,uEAAuE;;AAE3H;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB;AACpB;AACA,IAAG;AACH,qBAAoB;AACpB;;AAEA,IAAG;AACH,qBAAoB;AACpB;AACA,IAAG;AACH,qBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;;;;;;ACnQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;;;;;;;ACXA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ff90ac648b16fa2075cc\n **/","const GameView = require('./game_view');\n\nconst startEl = document.getElementById('new');\nconst endEl = document.getElementById('end');\nconst canvasEl = document.getElementById(\"main\");\nconst clockEl = document.getElementById(\"clock\");\nconst endTimeEl = document.getElementById(\"end-time\");\n\ncanvasEl.width = viewportSize.getWidth() - 5;\ncanvasEl.height = viewportSize.getHeight() - 4;\n\nconst ctx = canvasEl.getContext('2d');\n\nfunction startGame () {\n  clockEl.className = \"clock\";\n  clockEl.innerHTML = \"\";\n  endEl.className = \"toplevel-wrapper hidden\";\n  startEl.className += \" hidden\";\n\n  window.playing = true;\n  const gameView = new GameView(canvasEl.width, canvasEl.height, clockEl, endEl, endTimeEl).start(ctx);\n}\n\nwindow.playing = false;\ndocument.addEventListener(\"keydown\", () => {\n  if (!window.playing && event.keyCode === 32) {\n    startGame();\n  }\n});\n// no gameplay on mobile, but can at least watch the circles bounce...\ndocument.addEventListener(\"touchend\", () => {\n  if (!window.playing) {\n    startGame();\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/color_shift.js\n ** module id = 0\n ** module chunks = 0\n **/","const Game = require('./game');\nconst Player = require('./player');\n\nfunction GameView(dimX, dimY, clockEl, endEl, endTimeEl) {\n  this.dimX = dimX;\n  this.dimY = dimY;\n  this.clockEl = clockEl;\n  this.endEl = endEl;\n  this.endTimeEl = endTimeEl;\n  this.playing = false;\n}\n\nGameView.MOVES = {\n  'w':     [ 0,  -0.2],\n  'up':    [ 0,  -0.2],\n  'a':     [-0.2, 0],\n  'left':  [-0.2, 0],\n  's':     [ 0,   0.2],\n  'down':  [ 0,   0.2],\n  'd':     [ 0.2, 0],\n  'right': [ 0.2, 0],\n\n  'up+left':    [-0.2, -0.2],\n  'up+right':   [ 0.2, -0.2],\n  'down+left':  [-0.2,  0.2],\n  'down+right': [ 0.2,  0.2]\n};\n\nGameView.prototype.mapKeyHandlers = function () {\n  const player = this.player;\n\n  Object.keys(GameView.MOVES).forEach( k => {\n    const move = GameView.MOVES[k];\n    key(k, () => { player.thrust(move); }); // vendor/keymaster.js\n  });\n};\n\nGameView.prototype.start = function (ctx) {\n  this.time = 0;\n  this.startTime = Date.now();\n  this.game = new Game(this.dimX, this.dimY);\n  this.player = this.game.player;\n  this.playing = true;\n\n  if (this.cycle) {\n    clearInterval(this.cycle);\n  }\n\n  this.mapKeyHandlers();\n\n  requestAnimationFrame(this.cycle.bind(this, ctx));\n};\n\nGameView.prototype.cycle = function (ctx) {\n  this.time = Math.floor((Date.now() - this.startTime) / 1000);\n  if (this.time > 0) {\n    this.clockEl.innerHTML = `${this.time}`;\n  }\n\n  this.game.step();\n  this.game.render(ctx);\n\n  if (this.game.isOver() === false ) {\n    requestAnimationFrame(this.cycle.bind(this, ctx));\n  } else {\n    this.endingSequence();\n  }\n};\n\nGameView.prototype.endingSequence = function () {\n  this.endTimeEl.innerHTML = `Completed in ${this.time} seconds`;\n  this.endEl.className = \"toplevel-wrapper\";\n  this.clockEl.className = \"clock hidden\";\n  window.playing = false;\n};\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game_view.js\n ** module id = 1\n ** module chunks = 0\n **/","const Player = require('./player');\nconst Shape = require('./shape');\nconst Util = require('./util');\nconst Constants = require('./constants');\n\nconst NUM_SHAPES = 30;\n\nfunction Game (dimX, dimY) {\n  this.dimX = dimX;\n  this.dimY = dimY;\n  this.shapes = {\n    bright: [],\n    medium: [],\n    dim: []\n  };\n\n  for (let i = 0; i < NUM_SHAPES; i++) {\n    this.addShape();\n  }\n\n  const playerPos = [(dimX / 2), (dimY / 2)];\n  this.player = new Player(playerPos, this, this.invalidColors());\n  this.shapes.player = [this.player];\n}\n\nGame.prototype.step = function () {\n  this.isOver();\n  this.checkCollisions();\n  this.moveShapes();\n};\n\nGame.prototype.render = function (ctx) {\n  ctx.clearRect(0, 0, this.dimX, this.dimY);\n\n  this.forEachShape ( shape => {\n    shape.render(ctx);\n  });\n\n  this.player.render(ctx);\n};\n\nGame.prototype.checkCollisions = function () {\n  this.forEachShape ( shape => {\n    shape.alreadyCollided = [];\n  });\n  \n  this.forEachShape ( shape => {\n    if (shape.isCollidedWith(this.player) && shape !== this.player) {\n      shape.collidedWithPlayer();\n    }\n\n    this.forEachShape ( otherShape => {\n      if (otherShape !== shape) {\n        shape.isCollidedWith(otherShape);\n      }\n    });\n  });\n};\n\nGame.prototype.moveShapes = function () {\n  this.forEachShape(shape => {\n    shape.adjustForces();\n  });\n\n  this.forEachShape(shape => {\n    shape.move();\n  });\n\n  this.player.move();\n};\n\nGame.prototype.addShape = function (pos, velocity, radius) {\n  let shape;\n  if (!pos) {\n    pos = Util.randomPos(this.dimX, this.dimY);\n    shape = new Shape(pos, this);\n  } else {\n    shape = new Shape(pos, this, radius, velocity);\n  }\n\n  const clrCode = Object.keys(Constants.COLORS).filter( key => Constants.COLORS[key] === shape.color)[0];\n\n  this.shapes[clrCode].push(shape);\n};\n\nGame.prototype.removeShape = function (shape) {\n  const clrCode = Object.keys(Constants.COLORS).filter( key => Constants.COLORS[key] === shape.color)[0];\n\n  const idx = this.shapes[clrCode].indexOf(shape);\n  if (idx > -1) {\n    this.shapes[clrCode].splice(idx, 1);\n  }\n};\n\nGame.prototype.isOver = function () {\n  // Object.keys(this.shapes).forEach ( color => {\n  for (let i = 0; i < Object.keys(this.shapes).length; i ++) {\n    const color = Object.keys(this.shapes)[i];\n    if (this.shapes[color].length > 0 && color !== \"player\") {\n      return false;\n    }\n  }\n  return true;\n};\n\nGame.prototype.invalidColors = function () {\n  let colors = {};\n  Object.keys(Constants.COLORS).forEach( color => {\n    colors[Constants.COLORS[color]] = 0;\n  });\n\n  this.forEachShape ( shape => {\n    if (!shape.isPlayer) {\n      colors[shape.color] += 1;\n    }\n  });\n\n  let emptyColors = [];\n  Object.keys(colors).forEach( color => {\n    if (colors[color] < 1) {\n      emptyColors.push(color);\n    }\n  });\n\n  if (emptyColors.length < Object.keys(Constants.COLORS).length - 1 && this.player) {\n    emptyColors.push(this.player.color);\n  }\n\n  return emptyColors;\n};\n\nGame.prototype.forEachShape = function (callback) {\n  Object.keys(this.shapes).forEach( color => {\n    this.shapes[color].forEach ( shape => {\n      callback(shape);\n    });\n  });\n};\n\nmodule.exports = Game;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/game.js\n ** module id = 2\n ** module chunks = 0\n **/","const MovingShape = require('./moving_shape');\nconst Util = require('./util');\nconst Constants = require('./constants.js');\n\nconst RADIUS = 10;\nconst VELOCITY = [0, 0];\n\nconst Player = function (pos, game, invalidColors) {\n  this.isPlayer = true;\n  this.color = Util.randomColor(invalidColors);\n  MovingShape.call(this, pos, VELOCITY, RADIUS, this.color, game);\n};\n\nUtil.inherits(Player, MovingShape);\n\nPlayer.prototype.thrust = function (impulse) {\n  this.impulse[0] += impulse[0];\n  this.impulse[1] += impulse[1];\n};\n\nmodule.exports = Player;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/player.js\n ** module id = 3\n ** module chunks = 0\n **/","const Util = require('./util');\nconst Constants = require('./constants');\n\nfunction MovingShape (pos, velocity, radius, color, game) {\n  this.pos = pos;\n  this.velocity = velocity;\n  this.radius = radius;\n  this.color = color;\n  this.game = game;\n\n  this.mass = Math.pow(this.radius, 3);\n  this.reflectiveForce = [0, 0];\n  this.alreadyCollided = [];\n  this.impulse = [0, 0];\n  this.boundingForce = [1, 1];\n}\n\nMovingShape.prototype.render = function (ctx) {\n  ctx.fillStyle = this.color;\n  ctx.beginPath();\n\n  ctx.arc(\n    this.pos[0],\n    this.pos[1],\n    this.radius,0,\n    2 * Math.PI,\n    false\n  );\n\n  if (this.isPlayer) {\n    ctx.lineWidth = Constants.PLAYER_STROKE;\n    ctx.strokeStyle = this.color;\n    ctx.stroke();\n  } else {\n    ctx.fill();\n  }\n};\n\nMovingShape.prototype.move = function () {\n  this.ensureBounce(this.pos);\n\n  // if (this.isPlayer) {\n    this.windResit(this.velocity);\n  // }\n\n  this.pos[0] = this.pos[0] + (this.velocity[0]);\n  this.pos[1] = this.pos[1] + (this.velocity[1]);\n};\n\nMovingShape.prototype.windResit = function () {\n  const signage = [\n    (this.velocity[0] < 0) ? -1 : 1,\n    (this.velocity[1] < 0) ? -1 : 1\n  ];\n\n  const drag = [\n    Math.pow(this.velocity[0], 2) * this.radius * 0.0002 * signage[0],\n    Math.pow(this.velocity[1], 2) * this.radius * 0.0002 * signage[1]\n  ];\n\n  this.velocity = [\n    this.velocity[0] - drag[0],\n    this.velocity[1] - drag[1]\n  ];\n};\n\nMovingShape.prototype.adjustForces = function () {\n  if (this.reflectiveForce[0] === 0) {\n    this.reflectiveForce[0] = this.velocity[0];\n  }\n  if (this.reflectiveForce[1] === 0) {\n    this.reflectiveForce[1] = this.velocity[1];\n  }\n  this.velocity[0] = (this.reflectiveForce[0] + this.impulse[0]) * this.boundingForce[0];\n  this.velocity[1] = (this.reflectiveForce[1] + this.impulse[1]) * this.boundingForce[1];\n\n  this.reflectiveForce = [0, 0];\n  this.impulse = [0, 0];\n  this.boundingForce = [1, 1];\n};\n\nMovingShape.prototype.bounceOther = function (other) {\n  if (this.alreadyCollided.indexOf(other) === -1 &&\n      other.alreadyCollided.indexOf(this) === -1) {\n\n    const inelasticLoss = 0.9;\n    let velocityDiff = [], dispDiff = [];\n    velocityDiff[0] = this.velocity[0] - other.velocity[1];\n    velocityDiff[1] = this.velocity[1] - other.velocity[1];\n\n    dispDiff[0] = this.pos[0] - other.pos[0];\n    dispDiff[1] = this.pos[1] - other.pos[1];\n\n    // if both cirlces moving towards each other (avoid sticking)\n    if (Util.dotProduct(velocityDiff, dispDiff) < 0) {\n      this.alreadyCollided.push(other);\n      other.alreadyCollided.push(this);\n\n      let newReflectiveForce = [];\n      newReflectiveForce[0] = ( this.velocity[0] *\n        (this.mass - other.mass) +\n        (2 * other.mass * other.velocity[0])\n      ) / (this.mass + other.mass);\n      newReflectiveForce[1] = ( this.velocity[1] *\n        (this.mass - other.mass) +\n        (2 * other.mass * other.velocity[1])\n      ) / (this.mass + other.mass);\n\n      let newOtherReflectiveForce = [];\n      newOtherReflectiveForce[0] = ( other.velocity[0] *\n        (other.mass - this.mass) +\n        (2 * this.mass * this.velocity[0])\n      ) / (other.mass + this.mass);\n      newOtherReflectiveForce[1] = ( other.velocity[1] *\n        (other.mass - this.mass) +\n        (2 * this.mass * this.velocity[1])\n      ) / (other.mass + this.mass);\n\n      this.reflectiveForce[0] += (newReflectiveForce[0]) * inelasticLoss;\n      this.reflectiveForce[1] += (newReflectiveForce[1]) * inelasticLoss;\n      other.reflectiveForce[0] += (newOtherReflectiveForce[0]) * inelasticLoss;\n      other.reflectiveForce[1] += (newOtherReflectiveForce[1]) * inelasticLoss;\n  }\n    // stuck horizontally\n  } if (Math.abs(this.velocity[0]) + Math.abs(other.velocity[0]) < 0.2) {\n    let right, left;\n    if (this.pos[0] < other.pos[0]) {\n      left = this;\n      right = other;\n    } else {\n      left = other;\n      right = this;\n    }\n\n    // nudge apart\n    left.reflectiveForce[0] += -0.1;\n    right.reflectiveForce[0] += 0.1;\n\n    // stuck vertically\n  } else if (Math.abs(this.velocity[1]) + Math.abs(other.velocity[1]) < 0.2) {\n    let bottom, top;\n    if (this.pos[1] < other.pos[1]) {\n      top = this;\n      bottom = other;\n    } else {\n      top = other;\n      bottom = this;\n    }\n\n    // nudge apart\n    top.reflectiveForce[1] += -0.1;\n    bottom.reflectiveForce[1] += 0.1;\n  }\n};\n\n// at canvas boundries\nMovingShape.prototype.ensureBounce = function (pos) {\n  const bounce = this.outOfBounds(pos) || { axis: null, negative: false };\n\n  let reflection = -1;\n  let nudge = [0, 0];\n\n\n  if (bounce.x) {\n    if (bounce.xnegative) { // moving left\n      if (this.velocity[0] < 0) { this.boundingForce[0] = reflection; }\n      else if (this.velocity[0] > -0.2 && this.velocity[0] < 0) { nudge[0] = 0.2; }\n    } else {               // moving right\n      if (this.velocity[0] > 0) { this.boundingForce[0] = reflection; }\n      else if (this.velocity[0] < 0.2 && this.velocity[0] > 0) { nudge[0] = -0.2; }\n    }\n  } else if (bounce.y) {\n    if (bounce.ynegative) { // moving up\n      if (this.velocity[1] < 0) { this.boundingForce[1] = reflection; }\n      else if (this.velocity[1] > -0.2 && this.velocity[1] < 0) { nudge[1] = 0.2; }\n    } else {              // moving down\n      if (this.velocity[1] > 0) { this.boundingForce[1] = reflection; }\n      else if (this.velocity[1] < 0.2 && this.velocity[1] > 0) { nudge[1] = -0.2; }\n    }\n  }\n  if (this === this.game.player && nudge[1] !== 0) { console.log(this.reflectiveForce[1], nudge[1], this.boundingForce[1]); }\n\n  this.reflectiveForce[0] += nudge[0];\n  this.reflectiveForce[1] += nudge[1];\n};\n\nMovingShape.prototype.outOfBounds = function (pos) {\n  let output = {};\n\n  if ((pos[0] - this.radius) <= 0) {\n    output.x = true;    // left\n    output.xnegative = true;\n  } else if ((pos[0] + this.radius) >= this.game.dimX) {\n    output.x = true;    // right\n    output.xnegative= false;\n\n  } else if ((pos[1] - this.radius) <= 0) {\n    output.y = true;   //top\n    output.ynegative= true;\n  } else if ((pos[1] + this.radius) >= this.game.dimY) {\n    output.y = true;   //bottom\n    output.ynegative = false;\n  }\n\n  return output;\n};\n\nMovingShape.prototype.collidedWithPlayer = function () {\n  if (this.color === this.game.player.color && !this.isPlayer) {\n    // shrink the circle\n    this.radius -= 1;\n    this.mass = Math.pow(this.radius, 3);\n\n    // also pull the circle toward the center of the player\n    let pullx;\n    if (this.game.player.pos[0] < this.pos[0]) {\n      pullx = -0.7;\n    } else{\n      pullx = 0.7;\n    }\n\n    let pully;\n    if (this.game.player.pos[1] < this.pos[1]) {\n      pully = -0.7;\n    } else{\n      pully = 0.7;\n    }\n\n    this.reflectiveForce[0] += pullx;\n    this.reflectiveForce[1] += pully;\n\n    if (this.radius <= 1) {\n      this.game.removeShape(this);\n\n      // only pick from colors represented in game\n      let invalidColors = this.game.invalidColors();\n      (invalidColors.length >= Object.keys(Constants.COLORS).length) ? invalidColors = [] : invalidColors = invalidColors;\n      this.game.player.color = Util.randomColor(invalidColors);\n    }\n  }\n};\n\nMovingShape.prototype.isCollidedWith = function (other) {\n  const sumRadii = this.radius + other.radius;\n  const xDistance = Math.pow((this.pos[0] - other.pos[0]), 2);\n  const yDistance = Math.pow((this.pos[1] - other.pos[1]), 2);\n  const totDistance = Math.sqrt((xDistance + yDistance));\n\n  if (sumRadii >= totDistance) {\n    // don't bounce if collision is between player and shape of same color\n    if ((this.isPlayer && other.color !== this.color) || (!this.isPlayer && !other.isPlayer)) {\n      this.bounceOther(other);\n    }\n    return true;\n  } else {\n    return false;\n  }\n};\n\nmodule.exports = MovingShape;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/moving_shape.js\n ** module id = 4\n ** module chunks = 0\n **/","const Constants = require('./constants');\n\nconst Util = {\n  inherits (Child, Parent) {\n    function Surrogate(){}\n    Surrogate.constructor = Child;\n    Surrogate.prototype = Parent.prototype;\n    Child.prototype = new Surrogate();\n  },\n\n  randomVec (max) {\n    let x = (Math.random() * max);\n    let y = Math.sqrt(Math.pow(max, 2) - Math.pow(x, 2));\n\n    if (Math.random() > 0.5) {\n      x *= -1;\n    }\n    if (Math.random() > 0.5) {\n      y *= -1;\n    }\n\n    return [x, y];\n  },\n\n  randomColor (invalidColors) {\n\n    const codes = Object.keys(Constants.COLORS);\n    const codeSample = codes[Math.floor(Math.random() * Object.keys(Constants.COLORS).length)];\n\n    const sampledColor = Constants.COLORS[codeSample];\n    if (invalidColors && invalidColors.indexOf(sampledColor) !== -1) {\n      return Util.randomColor(invalidColors);\n    } else {\n      return sampledColor;\n    }\n  },\n\n  randomPos (maxWidth, maxHeight) {\n    return [\n      Math.floor((Math.random() * (maxWidth - Constants.MAX_RADIUS + 1)) + Constants.MAX_RADIUS),\n      Math.floor((Math.random() * (maxHeight - Constants.MAX_RADIUS + 1)) + Constants.MAX_RADIUS)\n    ];\n  },\n\n  randomRadius () {\n    return Math.floor((Math.random() * (Constants.MAX_RADIUS - 6 + 1)) + 6);\n  },\n\n  dotProduct (arr1, arr2) {\n    // assumes arr1.length === arr2.length\n    let dotProd = 0;\n    for (let i = 0; i < arr1.length; i++) {\n      dotProd += (arr1[i] * arr2[i]);\n    }\n    return dotProd;\n  }\n};\n\nmodule.exports = Util;\n\nwindow.maxWidth = viewportSize.getWidth() - 5;\nwindow.maxHeight = viewportSize.getHeight() - 4;\nwindow.Constants = Constants;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util.js\n ** module id = 5\n ** module chunks = 0\n **/","const Constants = {\n  COLORS: {\n    bright: \"#0cc9c7\",\n    medium: \"#308282\",\n    dim: \"#2e4852\"\n  },\n\n  PLAYER_STROKE: 6,\n  MAX_RADIUS: 40\n};\n\nmodule.exports = Constants;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/constants.js\n ** module id = 6\n ** module chunks = 0\n **/","const Util = require('./util');\nconst MovingShape = require('./moving_shape');\nconst Player = require('./player');\n\nconst Shape = function (pos, game, radius, velocity, color) {\n  if (!velocity) {\n    velocity = Util.randomVec(((Math.random() * 0.6) + 0.001));\n  }\n\n  radius = radius || Util.randomRadius();\n\n  color = color || Util.randomColor();\n\n  MovingShape.call(this, pos, velocity, radius, color, game);\n};\n\nUtil.inherits(Shape, MovingShape);\n\nmodule.exports = Shape;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/shape.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}